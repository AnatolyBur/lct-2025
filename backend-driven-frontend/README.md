# Руководство разработки

## 1. Подготовка к локальной разработке
1. Создать файл окружения на основе образца `cp env.example .env`, либо сконфиругировать самостоятельно.
2. Установить зависимости `yarn install`.
3. Запустить локальную среду `yarn start`.

## 2. Работа с API

### 2.1. Добавление новой интеграции

1. Создать новый класс с наследованием от `BaseApi` в `@/api/dirs/index.ts` и экспортировать его.
2. Проследовать п.2.2. Руководства разработки, работая с классом, созданным в п.1. этого раздела.

### 2.2. Добавление новой директории API

1. Создать файл `<Название директории>Api.ts` в `@/api/dirs/`.
2. Создать интерфейс `I<Название директории>Api` расширяющий интерфейс `IDirectionApi` в `@/api/types/` и реэкспортировать.
3. Создать класс `<Название директории>Api`, реализуюзий созданный интерфейс в созданном файле.
4. Добавить созданный класс в класс-коллектор `Api` (или иной в случае интеграций (п.2.1. Руководства разработки)) в `@/api/dirs/index.ts` и передать в него сам класс-коллектор.
5. Добавить методы, реализующие запросы к эндпоинтам, используя HTTP методы из поля `apiService`.
6. При необходмиости подключения нового сервиса API к Store проследуйте п.3.2. Руководства разработки

## 3. Работа со Store

### 3.1. Добавлние нового модуля в Store

1. Создать интерфейс `I<Название модуля>Store`, расширяющий интерфейс `IStoreModule`, в `@/store/types/<Название модуля>.ts` и реэкспортировать.
2. Создать класс `<Название модуля>Store.ts`, реализующий созданный интерфейс в `@/store/modules/<Название модуля>Store.ts`.
3. Добавить функцию `makeAutoObservable` с передачей в нее созданного модуля, в конце конструктора созданного модуля.
4. Расширить класс `RootStore`, добавив в него соответствующее поле для модуля и инициализировать класс модуля в конструкторе.
5. Из созданного модуля можно обращаться к другим модулям, либо API сервисам через поле `rs`.

### 3.2. Добавление новой интеграции

1. Расширить класс `RootStore`, добавив в него соответствующее поле для новоого класса-коллектора API (см. п.2.1. Руководства разработки) и инициализировать его в конструкторе.
2. Теперь другие модули могут обращаться внутри себя к новой интеграции через поле `rs`.

## Структура проекта

```markdown
├── src/           # корень
│   ├── apps/        # приложения (вьюхи, страницы — синонимы)
│   │   ├── app1/
│   │   │   ├── components/ # ⚛️-компоненты из app1 и только из него
│   │   │   ├── const/      # аналогично, константы
│   │   │   ├── contexts/   # ⚛️-контексты
│   │   │   ├── hooks/      # ⚛️-хуки
│   │   │   ├── interfaces/ # интерфейсы из app1 и только из него
│   │   │   ├── types/      # типы из app1 и только из него
│   │   │   ├── models/     # сторы-модели из app1 и только из него
│   │   │   ├── viewmodels/ # сторы-view-модели из app1 и только из него
│   │   │   ├── services/   # сервисы, специфичные для приложения app1 (api-сервисы лучше всегда класть в общий уровень)
│   │   │   ├── helpers/    # модули-хелперы, прим.: преобразователи дат, строк и т.п.
│   │   ├── ...
│   │   ├── appN/
│   │   │   ├── ...         # аналогично app1
│   │
│   ├── components/  # общие ⚛️-компоненты для 2+ приложений
│   ├── const/       # общие константы для 2+ приложений
│   ├── contexts/    # аналогично общие ⚛️-контексты
│   ├── hooks/       # общие ⚛️-хуки
│   ├── interfaces/  # общие для 2+ приложений интерфейсы
│   ├── types/       # общие для 2+ приложений типы
│   ├── models/      # сторы-модели, общие для 2+ приложений
│   ├── viewmodels/  # сторы-view-модели, общие для 2+ приложений
│   ├── services/    # сервисы, общие для 2+ приложений (например API-сервисы или синглтоны)
│   ├── utils/       # модули-хелперы, прим.: преобразователи дат, строк и т.п., общие для 2+ приложений
│   ├── pages/       # То что передаем в роутер
```
